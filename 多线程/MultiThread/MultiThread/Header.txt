/// 参考资料  http://www.cocoachina.com/ios/20170707/19769.html

/**
 一、多线程的概念
 
 进程：一个运行中的应用程序，是系统进行资源分配和调度的基本单位，操作系统结构的基础，主要管理资源；
 线程：进程的基本执行单元，一个进程对应多个线程；
 
 主线程：处理UI，所有更新UI的操作都必须在主线程执行，避免在主线程执行耗时操作，会造成界面卡顿；
 多线程：同一时刻，一个CPU只能处理1条线程，但是CPU可以在多条线程之间快速切换，只要切换的够快，就造成了多个线程共同执行的假象；
 
 多线程是通过提高资源的使用率来提高系统总体效率
 通过多线程将耗时操作放在后台执行
 */


/**
 二、线程的状态和生命周期
 
 新建：实例化线程对象；
 就绪：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度；
 运行：CPU负责调度可调度线程池中的线程。线程执行完成之前，状态会在就绪、运行之间切换。就绪和运行之间的状态变化由CPU负责，程序员无法干预。
 阻塞：当满足某些特定条件时，可以使用休眠或者锁，阻塞线程执行。
    sleepForTimeIntercal 休眠指定时长
    sleepUntilDate 休眠指定日期
    @synchronized(self) 互斥锁
 死亡：正常死亡，线程执行完毕；非正常死亡，在线程内部中止执行、在主线程中止线程对象
 
 [NSThread exit] 强行中止线程；后续所有代码都不会再执行；
 [thread cancel] 取消线程；线程并不会直接取消，只是给线程对象添加isCancelled标记；
 */


/**
 三、多线程的实现方案
 
 1、pthread（C）
 2、NSThread（OC）比较简单，可以直接操作线程对象；
 3、GCD（C）
 4、NSOperation（OC）基于GCD，但是更加面向对象
 
 */


/**
 四、线程安全
 当多个线程访问同一块资源时，容易引起数据错乱及数据安全问题；
 
 方法1：互斥锁（同步锁）
 
 @synchronized(锁对象) {
    // 需要锁定的代码
 }
 
 判断的时候锁对象要存在，如果代码中只有一个地方需要加锁，可以使用self作为锁对象，避免单独创建一个锁对象；
 加了互斥锁的代码，当新线程访问时，如果发现其他线程正在执行锁定代码，会进入休眠；
 
 方法2：自旋锁
 当新线程访问代码时，如果发现有其他线程正在锁定代码，新线程会循环访问代码，一直等待锁定代码的线程执行完毕。相当于不停地尝试执行代码，比较消耗性能；
 
 属性修饰符：
 nonatomic：
 非原子属性 非线程安全 同一时间可以有很多线程读写 不过效率高
 atomic：
 原子属性 线程安全 保证同一时间只有一个线程能够写入，多个线程可以同时取值
 atomic本身会自带自旋锁，需要消耗大量资源；
 */


/**
 五、NSThread
 */


/**
 六、GCD
 */

/**
 七、NSOperation
 */
